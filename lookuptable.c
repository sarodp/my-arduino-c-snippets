// 
// http://embeddedgurus.com/stack-overflow/2010/01/a-tutorial-on-lookup-tables-in-c
//

uint8_t pec_Update(uint8_t pec)

{
static const __flash uint8_t lookup[256] =
{
0x00U, 0x07U, 0x0EU, 0x09U, 0x1CU, 0x1BU, 0x12U, 0x15U,
0x38U, 0x3FU, 0x36U, 0x31U, 0x24U, 0x23U, 0x2AU, 0x2DU,
0x70U, 0x77U, 0x7EU, 0x79U, 0x6CU, 0x6BU, 0x62U, 0x65U,
0x48U, 0x4FU, 0x46U, 0x41U, 0x54U, 0x53U, 0x5AU, 0x5DU,
0xE0U, 0xE7U, 0xEEU, 0xE9U, 0xFCU, 0xFBU, 0xF2U, 0xF5U,
0xD8U, 0xDFU, 0xD6U, 0xD1U, 0xC4U, 0xC3U, 0xCAU, 0xCDU,
0x90U, 0x97U, 0x9EU, 0x99U, 0x8CU, 0x8BU, 0x82U, 0x85U,
0xA8U, 0xAFU, 0xA6U, 0xA1U, 0xB4U, 0xB3U, 0xBAU, 0xBDU,
0xC7U, 0xC0U, 0xC9U, 0xCEU, 0xDBU, 0xDCU, 0xD5U, 0xD2U,
0xFFU, 0xF8U, 0xF1U, 0xF6U, 0xE3U, 0xE4U, 0xEDU, 0xEAU,
0xB7U, 0xB0U, 0xB9U, 0xBEU, 0xABU, 0xACU, 0xA5U, 0xA2U,
0x8FU, 0x88U, 0x81U, 0x86U, 0x93U, 0x94U, 0x9DU, 0x9AU,
0x27U, 0x20U, 0x29U, 0x2EU, 0x3BU, 0x3CU, 0x35U, 0x32U,
0x1FU, 0x18U, 0x11U, 0x16U, 0x03U, 0x04U, 0x0DU, 0x0AU,
0x57U, 0x50U, 0x59U, 0x5EU, 0x4BU, 0x4CU, 0x45U, 0x42U,
0x6FU, 0x68U, 0x61U, 0x66U, 0x73U, 0x74U, 0x7DU, 0x7AU,
0x89U, 0x8EU, 0x87U, 0x80U, 0x95U, 0x92U, 0x9BU, 0x9CU,
0xB1U, 0xB6U, 0xBFU, 0xB8U, 0xADU, 0xAAU, 0xA3U, 0xA4U,
0xF9U, 0xFEU, 0xF7U, 0xF0U, 0xE5U, 0xE2U, 0xEBU, 0xECU,
0xC1U, 0xC6U, 0xCFU, 0xC8U, 0xDDU, 0xDAU, 0xD3U, 0xD4U,
0x69U, 0x6EU, 0x67U, 0x60U, 0x75U, 0x72U, 0x7BU, 0x7CU,
0x51U, 0x56U, 0x5FU, 0x58U, 0x4DU, 0x4AU, 0x43U, 0x44U,
0x19U, 0x1EU, 0x17U, 0x10U, 0x05U, 0x02U, 0x0BU, 0x0CU,
0x21U, 0x26U, 0x2FU, 0x28U, 0x3DU, 0x3AU, 0x33U, 0x34U,
0x4EU, 0x49U, 0x40U, 0x47U, 0x52U, 0x55U, 0x5CU, 0x5BU,
0x76U, 0x71U, 0x78U, 0x7FU, 0x6AU, 0x6DU, 0x64U, 0x63U,
0x3EU, 0x39U, 0x30U, 0x37U, 0x22U, 0x25U, 0x2CU, 0x2BU,
0x06U, 0x01U, 0x08U, 0x0FU, 0x1AU, 0x1DU, 0x14U, 0x13U,
0xAEU, 0xA9U, 0xA0U, 0xA7U, 0xB2U, 0xB5U, 0xBCU, 0xBBU,
0x96U, 0x91U, 0x98U, 0x9FU, 0x8AU, 0x8DU, 0x84U, 0x83U,
0xDEU, 0xD9U, 0xD0U, 0xD7U, 0xC2U, 0xC5U, 0xCCU, 0xCBU,
0xE6U, 0xE1U, 0xE8U, 0xEFU, 0xFAU, 0xFDU, 0xF4U, 0xF3U
};

pec = lookup[pec];
return pec;
}








unsigned char calculate_crc(const unsigned char * ptr, unsigned length, unsigned char crc)
{
static const unsigned char crc_table[256] =
{
0x00, 0x25, 0x4A, 0x6F, 0x94, 0xB1, 0xDE, 0xFB,
0x0D, 0x28, 0x47, 0x62, 0x99, 0xBC, 0xD3, 0xF6,
0x1A, 0x3F, 0x50, 0x75, 0x8E, 0xAB, 0xC4, 0xE1,
0x17, 0x32, 0x5D, 0x78, 0x83, 0xA6, 0xC9, 0xEC,
0x34, 0x11, 0x7E, 0x5B, 0xA0, 0x85, 0xEA, 0xCF,
0x39, 0x1C, 0x73, 0x56, 0xAD, 0x88, 0xE7, 0xC2,
0x2E, 0x0B, 0x64, 0x41, 0xBA, 0x9F, 0xF0, 0xD5,
0x23, 0x06, 0x69, 0x4C, 0xB7, 0x92, 0xFD, 0xD8,
0x68, 0x4D, 0x22, 0x07, 0xFC, 0xD9, 0xB6, 0x93,
0x65, 0x40, 0x2F, 0x0A, 0xF1, 0xD4, 0xBB, 0x9E,
0x72, 0x57, 0x38, 0x1D, 0xE6, 0xC3, 0xAC, 0x89,
0x7F, 0x5A, 0x35, 0x10, 0xEB, 0xCE, 0xA1, 0x84,
0x5C, 0x79, 0x16, 0x33, 0xC8, 0xED, 0x82, 0xA7,
0x51, 0x74, 0x1B, 0x3E, 0xC5, 0xE0, 0x8F, 0xAA,
0x46, 0x63, 0x0C, 0x29, 0xD2, 0xF7, 0x98, 0xBD,
0x4B, 0x6E, 0x01, 0x24, 0xDF, 0xFA, 0x95, 0xB0,
0xD0, 0xF5, 0x9A, 0xBF, 0x44, 0x61, 0x0E, 0x2B,
0xDD, 0xF8, 0x97, 0xB2, 0x49, 0x6C, 0x03, 0x26,
0xCA, 0xEF, 0x80, 0xA5, 0x5E, 0x7B, 0x14, 0x31,
0xC7, 0xE2, 0x8D, 0xA8, 0x53, 0x76, 0x19, 0x3C,
0xE4, 0xC1, 0xAE, 0x8B, 0x70, 0x55, 0x3A, 0x1F,
0xE9, 0xCC, 0xA3, 0x86, 0x7D, 0x58, 0x37, 0x12,
0xFE, 0xDB, 0xB4, 0x91, 0x6A, 0x4F, 0x20, 0x05,
0xF3, 0xD6, 0xB9, 0x9C, 0x67, 0x42, 0x2D, 0x08,
0xB8, 0x9D, 0xF2, 0xD7, 0x2C, 0x09, 0x66, 0x43,
0xB5, 0x90, 0xFF, 0xDA, 0x21, 0x04, 0x6B, 0x4E,
0xA2, 0x87, 0xE8, 0xCD, 0x36, 0x13, 0x7C, 0x59,
0xAF, 0x8A, 0xE5, 0xC0, 0x3B, 0x1E, 0x71, 0x54,
0x8C, 0xA9, 0xC6, 0xE3, 0x18, 0x3D, 0x52, 0x77,
0x81, 0xA4, 0xCB, 0xEE, 0x15, 0x30, 0x5F, 0x7A,
0x96, 0xB3, 0xDC, 0xF9, 0x02, 0x27, 0x48, 0x6D,
0x9B, 0xBE, 0xD1, 0xF4, 0x0F, 0x2A, 0x45, 0x60
};

while (length‐‐)
crc = crc_table[crc ^ *ptr++];
return crc;


/*
///
* =========================================
* static const __flash uint8_t lookup[256] =
* {0x00U, 0x07U, 0x0EU, 0x09U, ....};
*
* static const __flash uint8_t lookup[56] = { …};
*
* ===========================================


** static **
-------------
If static was omitted, 
then this table would be allocated and initialized 
on the stack every time the function is called. 
 
This is very slow (and hence self defeating) 
and will most likely lead to a stack overflow on smaller systems. 

As a result, a lookup table that is not declared static 
is almost certainly a mistake. 
 
The only exception that I am aware of to this rule is 
when the lookup table must be used by multiple modules
and hence must be declared so as to have global scope.



** const **
--------------------
By definition a lookup table is used to read data. 
As a result, writing to a lookup table is almost always a mistake. 
 
(There are exceptions, but you really need to know what you are doing 
if you are dynamically altering lookup tables). 

Thus to help catch unintended writes to a lookup table, 
one should always declare the array as const.

Note that sometimes this is superfluous 
if the array is forced into Flash, 
as described below.


** __flash **
----------------------
If one provides no memory modifier (such as __flash) 
then many embedded systems compilers will copy the array into RAM 
(even though it is declared as const). 
 
Given that RAM is normally a much more precious resource than Flash, 
then this is a very bad thing. 

As a result, one should give a memory specifier such as __flash
to force the array to be kept in Flash. 
 
Note that the syntax for doing so varies by compiler vendor. 
__flash is an IAR extension. 

I’ve also seen CODE (Keil) and ROM (Microchip) among others.


** [size] **
----------------------
 specific data type such as uint8_t
Almost by definition lookup tables can consume a lot of space. 
 
As a result it is very important that you be aware of exactly 
how much space is being consumed. 
The best way to do this is to use the C99 data types 
so that you know for sure what the underlying storage unit is. 

As a result, if your data type is ‘int’ then 
I’d suggest that you are doing yourself a disservice.


**Avoidance of incomplete array declarations **
------------------------------------------------
You should also note I have explicitly declared the array size as 256. 
I could of course have omitted this and had the declaration read as
static const __flash uint8_t lookup[] = { …};

However, I strongly recommend that you do not do this with lookup tables, 
as this is your first line of defense against 
inadvertently declaring the table with the wrong number of initializers.

///
*/
